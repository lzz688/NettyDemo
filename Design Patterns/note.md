###单例
确保一个类只有一个实例，并提供该实例的全局访问点
使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现
私有构造函数保证了不能通过构造函数来创建对象实例
只能通过公有静态函数返回唯一的私有静态变量
###简单工厂
在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口
简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类
让简单工厂类来决定应该用哪个具体子类来实例化
这样做能把客户类和具体子类的实现解耦
###工厂方法
定义了一个创建对象的接口，但由子类决定要实例化哪个类
工厂方法把实例化操作推迟到子类
工厂方法中，是由子类来创建对象
###抽象工厂
提供一个接口，用于创建 相关的对象家族 
抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象
并且这些对象是相关的，也就是说必须一起创建出来
而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同
###原型模式
使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。
###责任链
责任链，顾名思义，就是用来处理相关事务责任的一条执行链，
执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，
###命令模式
命令模式关注动作本身，通过将动作封装成对象实现调用者和底层实现相分离。
调用者只需要简单的下达命令，然后等待命令完成即可，对底层发生了什么完全不知情。
###解释器
给定一个语言，定义它的文法的一种表示，并定义一个解释器，
这个解释器使用该表示来解释语言中的句子
###迭代器
提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。
###观察者
定义对象之间的一对多依赖，当一个对象状态改变时，
它的所有依赖都会收到通知并且自动更新状态。
主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。
###状态
允许一个对象在其内部状态改变时改变它的行为。
对象看起来似乎修改了它的类，
(State Pattern)是设计模式的一种，属于行为模式。
状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。
把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。
###策略
定义一系列算法，封装每个算法，并使它们可以互换。
策略模式可以让算法独立于使用它的客户端。
###模板方法
定义算法框架，并将一些步骤的实现延迟到子类。
通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。
###适配器
让原来不兼容的两个接口协同工作
类适配器、对象适配器、接口适配器
目标接口：Target，该角色把其他类转换为我们期望的接口
被适配者: Adaptee 原有的接口，也是希望被改变的接口
适配器： Adapter, 将被适配者和目标接口组合到一起的类
###桥接
将抽象与实现分离开来，使它们可以独立变化
###组合
将对象组合成树形结构来表示“整体/部分”层次关系，
允许用户以相同的方式处理单独对象和组合对象。
###装饰
为对象动态添加功能。
装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），
具体组件的方法实现不需要依赖于其它对象，
而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。
所谓装饰，就是把这个装饰者套在被装饰者之上，
从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，
这属于它的功能，然后调用被装饰者的方法实现，
从而也保留了被装饰者的功能。
可以看到，具体组件应当是装饰层次的最低层，
因为只有具体组件的方法实现不需要依赖于其它对象。
###外观模式
提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。
###享元
利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。
Flyweight是抽象享元角色。它是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现
ConcreteFlyweight是具体享元角色，是具体的产品类，实现抽象角色定义的业务
UnsharedConcreteFlyweight是不可共享的享元角色，一般不会出现在享元工厂中
FlyweightFactory是享元工厂，它用于构造一个池容器，同时提供从池中获得对象的方法